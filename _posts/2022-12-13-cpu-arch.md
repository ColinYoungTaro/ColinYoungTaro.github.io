---
layout: post
title:  "计算机组成原理的扩展阅读"
date:   2022-12-13 13:35:46 +0800
categories: symbolic execution
author: Yutan Young
---
## CPU的基础结构
+ 指令存储器：按照指令地址存储指令码，根据指令计数器PC读出指令；
+ 译码部件：用于分析指令，判定指令类别；
+ 通用寄存器堆：参与计算的数据需要存储在寄存器中绝大多数指令都需要读取及修改寄存器；
+ 运算器：用于执行指令所指示的运算操作；
+ 数据存储器：按照地址存储数据，主要用于访存指令

<div align=center>
<img src="/images/arch/cpu.png" width="50%" height="50%">
</div>

## 流水线
利用寄存器存储一个指令周期的中间结果，供给下一个元件执行，每个元件空闲的时间减少，提高了指令的吞吐率

<div align=center style="padding-bottom: 10px">
<img src="/images/arch/pipeline.png" width="70%" height= "70%" >
</div>

指令流水线的思路非常理想，实现过程中会产生诸多问题，有很多因素会导致流水线陷入停滞，例如下一条指令的执行会依赖于上一条指令的结果，阻止流水线指令执行的情况被称为流水线的“冒险”

+ 结构冒险：两条指令使用的CPU资源冲突
+ 数据冒险：需要等待之前的指令完成读写操作
+ 控制冒险：条件跳转等指令需要根据之前指令的结果更改PC

### 结构冒险
**两条指令调度同一个CPU元件，产生资源冲突。冯诺依曼架构，指令与数据存储在一起，取指令与访存周期都会访问内存，可能产生资源冲突** 

现代计算机的解决办法是利用两个高速缓存分别存储指令与数据，让CPU分别从不同的存储器中取指令与数据，避免取指和取数据产生结构冒险

**不同指令可能同时访问寄存器堆，产生结构冲突**

采用发射队列的方式，指令被送入发送队列缓冲区中等待，并按照一定规则发送给计算单元参加运算，计算单元被占有则指令在等待状态，计算结束释放后继续发送指令

CPU存在一组不同的功能单元，每个功能单元完成他们自己的任务，所以可以尝试多条指令在他们自己的功能单元中并行执行。 为了实现这一目标，取指和解码/调度阶段必须强化使他们可以并行解码多条指令，然后将他们分发到“执行资源”中去

<div align=center>
<img src="/images/arch/emit.png" width="50%" height="50%">
</div>

### 数据冒险

**RAW：(Read After Write)** 一条指令需要使用之前指令的运算结果，但是结果还没有写回，导致流水线停滞

简单流水线的主要限制是它们使用循序指令发射与执行：指令按照程序顺序发射。如果一条指令停顿在流水线中，后续指令都不能继续执行。因此，如果流水线中两条相距很近的指令存在相关性，就会导致冒险和停顿，如果存在多个功能单元，这些单元也可能处于空闲状态。如果一条指令依赖于长时间运行的指令，那其之后的指令都不得不一直停顿。

``` asm 
load f0, 43(R1)
add f10, f12, f8
sub f12, f8, f14
```
上述汇编代码，load指令会根据R1偏移43个单位的内存里读取一个浮点数，add指令依赖于load指令的结果，因此要等待load访问内存完毕。若load遇到cache miss，读取耗时会很长，此时sub指令并不依赖前二者，但是仍然处在阻塞状态。

为了解决这些问题，提出乱序执行的概念

#### **Tomasulo结构**
<div align=center>
<img src="/images/arch/tomasulo.png" width="80%" height="80%">
</div>
+ 超标量流水线：有不同执行单元，可以并行执行不同类型的指令
+ 公共数据总线：计算单元的计算结果能立即通知依赖该数据执行的指令及写入寄存器。
+ 保留站/发射队列：每个对应的执行单元都配备一个保留站，发射的指令信息被缓存在保留站中，等待其依赖的数据被填充。一旦填充完毕，指令会被送入计算单元被执行，消除了RAW冒险


乱序执行除了写后读（RAW）冒险，但产生新的数据冒险问题：读后写（WAR）和写后写（WAW）

在顺序执行流水线结构下由于下一条指令的写过程必然在前一条指令的读写之后，所以不会产生上述冒险。然而在乱序执行过程中，后续指令的“写操作”可能被提前执行，导致之前的指令读取到错误的数据
实现乱序执行与动态调度，必须避免上述数据冒险，可以使用寄存器重命名方法

<div align=center>
<img src="/images/arch/register.png" width="80%" height="80%">
</div>
<br>

WAW与WAR指令虽然会产生数据冒险，但是后续指令的执行都覆盖了之前指令执行的结果，因此并不强依赖于前一条指令的执行，
通过寄存器重命名，修改后序指令写操作的目的寄存器，就能分离两个操作，消除冒险（如上图）

#### **ROQ重排序队列**
Tomasulo结构添加重排序缓存，执行完毕后的结果会先写入缓存内，再按序提交写入逻辑寄存器。便于上层应用调试程序和实现分支预测功能。
如果指令不能从逻辑寄存器堆读取到所需数据，就会根据寄存器结果状态表的查询结果查询数据
若数据由正在执行的指令得到：指令需要在保留站中监听CDB，直到获取到数据
若数据正在ROQ中未提交：指令会从ROB中读出数据
<div align=center>
<img src="/images/arch/roq.png" width="80%" height="80%">
</div>
<br>


## 参考阅读
[Tomasulo](https://zhuanlan.zhihu.com/p/499978902)
